### Создаем приложение для которого мы будем собирать image

Docker нужен, чтобы запускать код в контейнерах. Именно эта тема научит упаковывать любой код в image, запускать его и выгружать image в публичное хранилище образов dockerhub

Для самого простого примера будем использовать скрипт который раз в 3 секунды выводит сообщение

```sh
#!/bin/bash

echo "$(date) [INFO] Начинаю работать"

# используем цикл while который будет работать бесконечно
while true
do
echo "$(date) [INFO] Скрипт запущен, спим 3 секунды"
sleep 3
done
```

### Dockerfile основы

Все docker images собираются по шагам которые описаны в Dockerfile

Шаги бывают разные, но нам дня начала нужны будут только:

- `FROM` - базовый image на основании которого будем собирать наш image, например `FROM ubuntu:22.04` значит что мы берем базовый образ Ubuntu и можем дальше использовать программы (apt, curl, top и тд) которые есть в Ubuntu и также библиотеки (инстукции как програмам взаимодействовать с системой)
   > То есть там будет уже и `bash` который нужен для запуска нашего скрипта и команда `date` которая выводит дату и используется в скрипте
- `COPY` - скопировать что-то с нашей машины в контейнер, обычно копируем программу и все что ей нужно для запуска, в нашем случае скопируем только скрипт который описали выше. Записывать так `COPY ПУТЬ_К_ФАЙЛУ_НА_МАШИНЕ ПУТЬ_К_ФАЙЛУ_ВНУТРИ_КОНТЕЙНЕРА`, например `COPY ./script.sh /script.sh`
- `RUN` - вот мы уже взяли базовый образ с Ubuntu и скопировали туда наш скрипт, но забыли сделать его запускаемым. Для запуска команд во время сборки образа мы используем команду `RUN apt install -y ПРОГРАММА_КОТОРАЯ_УБЕДТ_НУЖНА_ДЛЯ_ЗАПУСКА`, напримеро сделаем скрипт который скопировали внутрь контейнера запускаемым `RUN chmod +x /script.sh`
- `ENTRYPOINT` и `CMD` - нужны для того чтобы определить как запускать нашу программу при старте контейнера, например будет работать и `CMD ["/script.sh"]` и `ENTRYPOINT ["/script.sh"]` (нужно брать в скобки `["..."]` чтобы напрямую запускался скрипт, а не через sh или bash)
   > Могут работать по отдельности и вместе (когда вместе то то что в CMD дописывается в конец к ENTRYPOINT)
   > ```Dockerfile
   > ENTRYPOINT ["ls", "/usr"]  
   > CMD ["/var"]
   > ```
   > Команда которая будет запущенна в итоге: `ls /usr /var`
- `WORKDIR` - нужна для того чтобы определить из какой папки запускать наш скрипт (по умолчанию из папки `/`). Например `WORKDIR /etc` и тогда если `ENTRYPOINT ["ls", "-lah"]` выведет при запуске контейнера содержимое папки `/etc`, а не `/`
   > Создаст папку если ее еще нет, очень удобная команда когда есть куча файлов необходимых для запуска нашего кода, а копировать все `/` нет смысла, так как у нас есть своя папки `etc` и мы не хотим заливать ее содержимое в `/etc` и поэтому создаем WORKDIR в которую уже поместим все что нам нужно и ничего лишнего там не будет

Теперь можно перейти к созданию первого Dockerfile

```Dockerfile
FROM ubuntu:22.04

WORKDIR /app

COPY ./script.sh /app/script.sh

RUN chmod u+x script.sh

CMD ["/app/script.sh"]
```

Файл с инструкциями создан, теперь соберем из него наш первый image, это делается командой
```sh
cat Dockerfile | docker build --tag myfirstapp:1.0.0 .
```

Которая соберет нам образ `myfistapp` версии `1.0.0` следуя инструкциям из нашего `Dockerfile`

Теперь запустим наш образ, для этого (как бонус, посмотри данные о нем `docker images`)
```sh
docker run --rm myfirstapp:1.0.0
```
- `--rm` - автоматически удалит контейнер, когда он завершит работу (мы его убьем или сам умрет)

### DockerHub общедоступное место для хранения образов

Когда мы пытаемся запустить например mineraft в docker контейнере, docker будет в первую очередь искать, есть ли image для minecraft у нас локально, а потом если не найдет в DockerHub и если там есть, то скачает его и только тогда запустит

1. Создаем аккаунт: https://hub.docker.com/ 
2. 
